# task-decompose-quickstart
## 下面是一个prompt-task_decompose()
```
您需要将一个复杂的用户问题分解为一些简单的子任务，并让模型逐步执行。

这是用户的问题：{question}

请注意：

您应该仅将这个复杂的用户问题分解为一些可以通过使用单一工具轻松执行的简单子任务。
每个简单子任务应该用自然语言表达。
每个子任务应包含原始问题的必要信息，并且应该是完整的、明确的和自洽的。
您只能以可解析的 JSON 格式输出您选择的工具的 ID。输出示例如下：
'''
{{"Tasks": ["任务1", "任务2", ...]}}
'''
输出：

```
## 以下是3个具体例子
```
以下是三个可以作为`{question}`填充的复杂任务示例：

1. "我需要为即将到来的夏天准备一次家庭度假，包括选择目的地、预订机票和酒店，并为全家人准备必需的旅行用品。我还需要考虑到旅行保险和特别的饮食要求。"

2. "我想为我的新家装修设计一个现代风格的客厅，需要选择适合的家具、窗帘和装饰品，并考虑到室内照明和颜色搭配。同时，我还需要确保所有材料的环保标准和预算控制。"

3. "我正在计划一个专业会议，需要处理与地点选择、参与者邀请、日程安排和餐饮服务相关的各种事务。此外，我还需要设立一套技术支持系统来进行在线直播和记录会议内容。"
```


## 下面是一个prompt-task_topology()
```
鉴于一个复杂用户问题，我已将该问题分解成一些简单的子任务。我认为这些任务之间存在着逻辑连接和顺序。因此，你需要帮助我输出这些逻辑连接和顺序。
你必须仅以可解析的JSON格式输出，格式如下：

[
  {
    "task": "task",
    "id": "task_id",
    "dep": ["dependency_task_id1", "dependency_task_id2", ...]
  }
]

其中‘dep’字段表示生成新资源的前一个任务的id，当前任务依赖于该资源。如果没有依赖项，则将‘dep’设置为-1。
这是用户的问题：{question}
这些是该问题的子任务：
{task_ls}
输出：
```
## 以下是3个具体例子
当然，下面是三个示例，可以用来填充 `{question}` 和 `{task_ls}`：

例子1：
```
{question}: 如何准备一道经典的意大利面食？
{task_ls}:
1. 收集食材
2. 准备面团
3. 制作意大利面条
4. 煮意大利面
5. 准备酱料
6. 搭配酱料和意大利面
7. 享用美食
```

例子2：
```
{question}: 怎样在Python中实现一个简单的计算器？
{task_ls}:
1. 定义基本的数学运算功能
2. 实现用户输入的功能
3. 编写主函数
4. 测试代码
```

例子3：
```
{question}: 如何组织一场成功的线上研讨会？
{task_ls}:
1. 确定研讨会的主题和目标
2. 确定研讨会的日期、时间和时长
3. 确定参与者和主持人
4. 设置线上会议平台
5. 发送邀请邮件
6. 准备研讨会的议程和资料
7. 进行技术测试和准备
8. 主持研讨会
9. 收集反馈和总结经验
```

## 下面是prompt-answer_generation_direct()
```
你需要回答用户的问题。
这是用户的问题：{task}
输出：
```

## 下面是prompt-answer_summarize()
```
我们将复杂的用户问题分解为简单的子任务，并提供每个简单子任务的答案。您需要组织这些答案，形成一个自洽的最终答案给用户。

这是用户的问题: {question}。
这些是子任务及其答案: {answer_task}。
最终答案:
```

## 下面是tool_check()
```
**提示：**

作为一款强大的语言模型，你能够根据积累的知识来回答用户的问题。但是，在某些情况下，你需要使用外部API来准确地回答问题。因此，你需要检查用户的问题是否需要调用外部API来解决。

以下是一些建议来帮助你进行检查：

1. 如果用户的问题需要实时信息，由于你的知识库不是实时更新的，任何这样的问题都需要进行API调用。
2. 如果你需要获取信息（例如ID、姓名、电话号码、地理位置、等级等），如果不确定，你需要调用数据库API。
3. 如果问题需要数据库搜索或互联网研究来生成答案，这是另一种需要进行API调用的情况。

需要时，请输出“YES”；如果不需要，请输出“NO”。你需要先给出理由，然后决定是否保留。你必须只输出可解析的JSON格式。两个示例输出如下：

示例1: {"Reason": "你认为不需要调用外部API来解决用户问题的原因", "Choice": "No"}

示例2: {"Reason": "你认为需要调用外部API来解决用户问题的原因", "Choice": "Yes"}

这是用户的问题：{task}

输出:
```

## 下面是answer_check()
```
请检查回答是否合理准确。如果是，请输出'YES'；如果不是，请输出'NO'。

你需要先给出理由，然后决定回答是否合理准确。你必须以可解析的JSON格式输出。两个示例输出如下：

示例1：{"Reason": "你认为回答可以合理准确回答问题的理由", "Choice": "Yes"}

示例2：{"Reason": "你认为回答无法合理准确回答问题的理由", "Choice": "No"}

这是用户的问题：{question}

这是回答：{answer}

输出：
```

## task_execution函数()
```
这段代码是一个任务执行函数，它的执行步骤可以简单描述如下：

1. 使用一个进度条（tqdm）追踪文件处理进度。
2. 遍历测试数据集（test_data）中的每一项，从指定的起始索引开始。
3. 对于每个测试数据项，提取其中的问题（query）。
4. 使用特定模型（model_name）对问题进行分解，得到任务列表（task_ls）。
5. 对任务列表中的每个任务，进行工具检查（tool_check）。
6. 根据工具检查的结果，选择直接生成答案（answer_generation_direct）或需要工具支持的方式生成答案。
7. 如果需要工具支持，从数据集中检索合适的工具，并根据任务依赖关系决定工具的使用顺序。
8. 根据检索到的工具和任务依赖关系，调用相应的工具，获取结果，并生成答案。
9. 对生成的答案进行检查（answer_check），如果通过检查，则将答案添加到最终答案列表中。
10. 对于每个测试数据项，整理最终的答案，并将执行日志写入到输出文件中。
11. 更新处理进度条。
12. 重复以上步骤，直到所有测试数据项处理完成。
```
