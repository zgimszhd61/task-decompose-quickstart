# task-decompose-quickstart
## 下面是一个prompt-task_decompose()
```
您需要将一个复杂的用户问题分解为一些简单的子任务，并让模型逐步执行。

这是用户的问题：{question}

请注意：

您应该仅将这个复杂的用户问题分解为一些可以通过使用单一工具轻松执行的简单子任务。
每个简单子任务应该用自然语言表达。
每个子任务应包含原始问题的必要信息，并且应该是完整的、明确的和自洽的。
您只能以可解析的 JSON 格式输出您选择的工具的 ID。输出示例如下：
'''
{{"Tasks": ["任务1", "任务2", ...]}}
'''
输出：

```
## 以下是3个具体例子
```
以下是三个可以作为`{question}`填充的复杂任务示例：

1. "我需要为即将到来的夏天准备一次家庭度假，包括选择目的地、预订机票和酒店，并为全家人准备必需的旅行用品。我还需要考虑到旅行保险和特别的饮食要求。"

2. "我想为我的新家装修设计一个现代风格的客厅，需要选择适合的家具、窗帘和装饰品，并考虑到室内照明和颜色搭配。同时，我还需要确保所有材料的环保标准和预算控制。"

3. "我正在计划一个专业会议，需要处理与地点选择、参与者邀请、日程安排和餐饮服务相关的各种事务。此外，我还需要设立一套技术支持系统来进行在线直播和记录会议内容。"
```


## 下面是一个prompt-task_topology()
```
鉴于一个复杂用户问题，我已将该问题分解成一些简单的子任务。我认为这些任务之间存在着逻辑连接和顺序。因此，你需要帮助我输出这些逻辑连接和顺序。
你必须仅以可解析的JSON格式输出，格式如下：

[
  {
    "task": "task",
    "id": "task_id",
    "dep": ["dependency_task_id1", "dependency_task_id2", ...]
  }
]

其中‘dep’字段表示生成新资源的前一个任务的id，当前任务依赖于该资源。如果没有依赖项，则将‘dep’设置为-1。
这是用户的问题：{question}
这些是该问题的子任务：
{task_ls}
输出：
```
## 以下是3个具体例子
当然，下面是三个示例，可以用来填充 `{question}` 和 `{task_ls}`：

例子1：
```
{question}: 如何准备一道经典的意大利面食？
{task_ls}:
1. 收集食材
2. 准备面团
3. 制作意大利面条
4. 煮意大利面
5. 准备酱料
6. 搭配酱料和意大利面
7. 享用美食
```

例子2：
```
{question}: 怎样在Python中实现一个简单的计算器？
{task_ls}:
1. 定义基本的数学运算功能
2. 实现用户输入的功能
3. 编写主函数
4. 测试代码
```

例子3：
```
{question}: 如何组织一场成功的线上研讨会？
{task_ls}:
1. 确定研讨会的主题和目标
2. 确定研讨会的日期、时间和时长
3. 确定参与者和主持人
4. 设置线上会议平台
5. 发送邀请邮件
6. 准备研讨会的议程和资料
7. 进行技术测试和准备
8. 主持研讨会
9. 收集反馈和总结经验
```

## 下面是prompt-answer_generation_direct()
```
你需要回答用户的问题。
这是用户的问题：{task}
输出：
```

## 下面是prompt-answer_summarize()
```
我们将复杂的用户问题分解为简单的子任务，并提供每个简单子任务的答案。您需要组织这些答案，形成一个自洽的最终答案给用户。

这是用户的问题: {question}。
这些是子任务及其答案: {answer_task}。
最终答案:
```

## 下面是tool_check()
```
**提示：**

作为一款强大的语言模型，你能够根据积累的知识来回答用户的问题。但是，在某些情况下，你需要使用外部API来准确地回答问题。因此，你需要检查用户的问题是否需要调用外部API来解决。

以下是一些建议来帮助你进行检查：

1. 如果用户的问题需要实时信息，由于你的知识库不是实时更新的，任何这样的问题都需要进行API调用。
2. 如果你需要获取信息（例如ID、姓名、电话号码、地理位置、等级等），如果不确定，你需要调用数据库API。
3. 如果问题需要数据库搜索或互联网研究来生成答案，这是另一种需要进行API调用的情况。

需要时，请输出“YES”；如果不需要，请输出“NO”。你需要先给出理由，然后决定是否保留。你必须只输出可解析的JSON格式。两个示例输出如下：

示例1: {"Reason": "你认为不需要调用外部API来解决用户问题的原因", "Choice": "No"}

示例2: {"Reason": "你认为需要调用外部API来解决用户问题的原因", "Choice": "Yes"}

这是用户的问题：{task}

输出:
```

## 下面是answer_check()
```
请检查回答是否合理准确。如果是，请输出'YES'；如果不是，请输出'NO'。

你需要先给出理由，然后决定回答是否合理准确。你必须以可解析的JSON格式输出。两个示例输出如下：

示例1：{"Reason": "你认为回答可以合理准确回答问题的理由", "Choice": "Yes"}

示例2：{"Reason": "你认为回答无法合理准确回答问题的理由", "Choice": "No"}

这是用户的问题：{question}

这是回答：{answer}

输出：
```

## task_execution函数()
```
这段代码是一个任务执行函数，它的执行步骤可以简单描述如下：

1. 使用一个进度条（tqdm）追踪文件处理进度。
2. 遍历测试数据集（test_data）中的每一项，从指定的起始索引开始。
3. 对于每个测试数据项，提取其中的问题（query）。
4. 使用特定模型（model_name）对问题进行分解，得到任务列表（task_ls）。
5. 对任务列表中的每个任务，进行工具检查（tool_check）。
6. 根据工具检查的结果，选择直接生成答案（answer_generation_direct）或需要工具支持的方式生成答案。
7. 如果需要工具支持，从数据集中检索合适的工具，并根据任务依赖关系决定工具的使用顺序。
8. 根据检索到的工具和任务依赖关系，调用相应的工具，获取结果，并生成答案。
9. 对生成的答案进行检查（answer_check），如果通过检查，则将答案添加到最终答案列表中。
10. 对于每个测试数据项，整理最终的答案，并将执行日志写入到输出文件中。
11. 更新处理进度条。
12. 重复以上步骤，直到所有测试数据项处理完成。
```

----------------------

## 另一种简化的分解任务方法task_decompose()
```
我们有 Spotify 数据库以及以下工具：
{Tool_dic}
你需要将一个复杂用户问题分解成一些简单的子任务，并让模型按照这些工具逐步执行它。请注意：

你应该将任务分解成适当的子任务以使用上述提到的工具。
你不仅应列出子任务，还应列出用于解决此子任务的工具的 ID。
如果你认为不需要使用工具来解决子任务，只需将其留空为{{"ID": -1}}。
你必须考虑工具之间的逻辑连接、顺序和约束，以实现正确的工具路径。
你必须仅以可解析的 JSON 格式输出你选择的工具的 ID。两个示例输出如下：
'''问题：暂停播放器
示例 1：[{{"Task":"获取用户当前播放状态信息", "ID":15}}, {{"Task":"暂停用户账户的播放", "ID":19}}]'''
这是用户的问题：{question}
输出：

```


## choose_tool()
```
用户问题: {question}
你可以选择以下工具来解决问题:
工具列表:
{Tool_list}

请注意:
1. 你应该只选择工具列表中的一个工具来解决这个问题。
2. 你必须以可解析的JSON格式仅输出你选择的工具的ID。两个示例输出如下:
'''
示例 1: {"ID": 1}
示例 2: {"ID": 2}
'''

输出:
```

## choose_parameter()
```
这是一个API工具文档。根据用户的问题，你需要根据API工具文档输出参数，以成功调用API来解决用户的问题。

这是API工具文档：{api_dic}

请注意：

1. API工具文档中的示例可以帮助你更好地理解API的使用。
2. 确保你输出的参数是正确的。输出必须包含必需的参数，并根据问题可以包含可选参数。如果必需参数和可选参数中没有参数，则保留为{{"Parameters": {}}}。
3. 如果用户的问题提到了其他API，请仅考虑我提供的API工具文档，不考虑其他API。
4. 如果需要多次使用此API，请将“Parameters”设置为一个列表。
5. 你必须以可解析的JSON格式输出。两个示例输出如下：

\`\`\`
示例1: {"Parameters":{"input": [1,2,3]}}
示例2: {"Parameters":[{"input": [1,2,3]}, {"input": [2,3,4]}]}
\`\`\`

这是用户的问题：{question}
输出：
```

## choose_parameter_depend()

```
给定用户的问题和 API 工具文档，您需要根据 API 工具文档输出参数，以成功调用 API 来解决用户的问题。

请注意：

1. API 工具文档中的示例可以帮助您更好地理解 API 的使用。
2. 确保您输出的参数是正确的。输出必须包含必需参数，并根据问题可以包含可选参数。如果必需参数和可选参数中没有参数，则将其保留为 {{\"Parameters\":{{}}}}。
3. 如果用户的问题涉及其他 API，请仅考虑我提供的 API 工具文档，不要考虑其他 API。
4. 问题可能依赖于其他问题的答案，因此我们将提供以前问题和答案的日志供您参考。
5. 如果您需要多次使用此 API，请将 \"Parameters\" 设置为列表。
6. 您必须仅以可解析的 JSON 格式输出。两个示例输出如下：

Example 1: {\"Parameters\":{{\"input\": [1,2,3]}}}
Example 2: {\"Parameters\":[{{\"input\": [1,2,3]}}, {{\"input\": [2,3,4]}}]}

这是以前的问题和答案日志：
{previous_log}

这是当前用户的问题：{question}

这是 API 工具文档：{api_dic}

输出：

```


## answer_generation()
```
**用户提问提示：**
你应该根据API工具的响应来回答问题。
请注意：
1. 根据API的响应合理有效地回答问题，用自然语言表达。
2. 用户无法直接获得API的响应，因此你需要充分利用响应，并尽可能详细地提供满足用户问题的信息。
3. 如果API工具在响应中没有提供有用信息，请根据自己的知识进行回答。

这是用户的问题：
{用户提出的问题}

这是API的响应：
{API的响应}

输出：

```


## answer_generation_depend()
```
请根据 API 工具的响应输出回答问题。
请注意：
  1. 尝试将响应组织成自然语言的答案。
  2. 我们不会向用户显示 API 响应，因此您需要充分利用响应，并尽可能详细地提供可以满足用户问题的信息。
  3. 如果 API 工具在响应中没有提供有用信息，请根据您的知识回答。
  4. 问题可能依赖于其他问题的答案，因此我们将提供先前问题和答案的日志。

先前问题和答案的日志如下：
{previous_log}
这是用户的问题：{question}
这是 API 工具的响应输出：
{call_result}
我们不会向用户显示 API 响应，因此您需要充分利用响应，并尽可能详细地提供可以满足用户问题的信息。
输出：

```


