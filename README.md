# task-decompose-quickstart
## 下面是一个prompt-task_decompose()
```
您需要将一个复杂的用户问题分解为一些简单的子任务，并让模型逐步执行。

这是用户的问题：{question}

请注意：

您应该仅将这个复杂的用户问题分解为一些可以通过使用单一工具轻松执行的简单子任务。
每个简单子任务应该用自然语言表达。
每个子任务应包含原始问题的必要信息，并且应该是完整的、明确的和自洽的。
您只能以可解析的 JSON 格式输出您选择的工具的 ID。输出示例如下：
'''
{{"Tasks": ["任务1", "任务2", ...]}}
'''
输出：

```
## 以下是3个具体例子
```
以下是三个可以作为`{question}`填充的复杂任务示例：

1. "我需要为即将到来的夏天准备一次家庭度假，包括选择目的地、预订机票和酒店，并为全家人准备必需的旅行用品。我还需要考虑到旅行保险和特别的饮食要求。"

2. "我想为我的新家装修设计一个现代风格的客厅，需要选择适合的家具、窗帘和装饰品，并考虑到室内照明和颜色搭配。同时，我还需要确保所有材料的环保标准和预算控制。"

3. "我正在计划一个专业会议，需要处理与地点选择、参与者邀请、日程安排和餐饮服务相关的各种事务。此外，我还需要设立一套技术支持系统来进行在线直播和记录会议内容。"
```


## 下面是一个prompt-task_topology()
```
鉴于一个复杂用户问题，我已将该问题分解成一些简单的子任务。我认为这些任务之间存在着逻辑连接和顺序。因此，你需要帮助我输出这些逻辑连接和顺序。
你必须仅以可解析的JSON格式输出，格式如下：

[
  {
    "task": "task",
    "id": "task_id",
    "dep": ["dependency_task_id1", "dependency_task_id2", ...]
  }
]

其中‘dep’字段表示生成新资源的前一个任务的id，当前任务依赖于该资源。如果没有依赖项，则将‘dep’设置为-1。
这是用户的问题：{question}
这些是该问题的子任务：
{task_ls}
输出：
```
## 以下是3个具体例子
当然，下面是三个示例，可以用来填充 `{question}` 和 `{task_ls}`：

例子1：
```
{question}: 如何准备一道经典的意大利面食？
{task_ls}:
1. 收集食材
2. 准备面团
3. 制作意大利面条
4. 煮意大利面
5. 准备酱料
6. 搭配酱料和意大利面
7. 享用美食
```

例子2：
```
{question}: 怎样在Python中实现一个简单的计算器？
{task_ls}:
1. 定义基本的数学运算功能
2. 实现用户输入的功能
3. 编写主函数
4. 测试代码
```

例子3：
```
{question}: 如何组织一场成功的线上研讨会？
{task_ls}:
1. 确定研讨会的主题和目标
2. 确定研讨会的日期、时间和时长
3. 确定参与者和主持人
4. 设置线上会议平台
5. 发送邀请邮件
6. 准备研讨会的议程和资料
7. 进行技术测试和准备
8. 主持研讨会
9. 收集反馈和总结经验
```

## 下面是prompt-answer_generation_direct()
```
你需要回答用户的问题。
这是用户的问题：{task}
输出：
```

## 下面是prompt-answer_summarize()
```
我们将复杂的用户问题分解为简单的子任务，并提供每个简单子任务的答案。您需要组织这些答案，形成一个自洽的最终答案给用户。

这是用户的问题: {question}。
这些是子任务及其答案: {answer_task}。
最终答案:
```

## 下面是tool_check()
```
**提示：**

作为一款强大的语言模型，你能够根据积累的知识来回答用户的问题。但是，在某些情况下，你需要使用外部API来准确地回答问题。因此，你需要检查用户的问题是否需要调用外部API来解决。

以下是一些建议来帮助你进行检查：

1. 如果用户的问题需要实时信息，由于你的知识库不是实时更新的，任何这样的问题都需要进行API调用。
2. 如果你需要获取信息（例如ID、姓名、电话号码、地理位置、等级等），如果不确定，你需要调用数据库API。
3. 如果问题需要数据库搜索或互联网研究来生成答案，这是另一种需要进行API调用的情况。

需要时，请输出“YES”；如果不需要，请输出“NO”。你需要先给出理由，然后决定是否保留。你必须只输出可解析的JSON格式。两个示例输出如下：

示例1: {"Reason": "你认为不需要调用外部API来解决用户问题的原因", "Choice": "No"}

示例2: {"Reason": "你认为需要调用外部API来解决用户问题的原因", "Choice": "Yes"}

这是用户的问题：{task}

输出:
```

## 下面是answer_check()
```
请检查回答是否合理准确。如果是，请输出'YES'；如果不是，请输出'NO'。

你需要先给出理由，然后决定回答是否合理准确。你必须以可解析的JSON格式输出。两个示例输出如下：

示例1：{"Reason": "你认为回答可以合理准确回答问题的理由", "Choice": "Yes"}

示例2：{"Reason": "你认为回答无法合理准确回答问题的理由", "Choice": "No"}

这是用户的问题：{question}

这是回答：{answer}

输出：
```

## task_execution函数()
```
这段代码是一个任务执行函数，它的执行步骤可以简单描述如下：

1. 使用一个进度条（tqdm）追踪文件处理进度。
2. 遍历测试数据集（test_data）中的每一项，从指定的起始索引开始。
3. 对于每个测试数据项，提取其中的问题（query）。
4. 使用特定模型（model_name）对问题进行分解，得到任务列表（task_ls）。
5. 对任务列表中的每个任务，进行工具检查（tool_check）。
6. 根据工具检查的结果，选择直接生成答案（answer_generation_direct）或需要工具支持的方式生成答案。
7. 如果需要工具支持，从数据集中检索合适的工具，并根据任务依赖关系决定工具的使用顺序。
8. 根据检索到的工具和任务依赖关系，调用相应的工具，获取结果，并生成答案。
9. 对生成的答案进行检查（answer_check），如果通过检查，则将答案添加到最终答案列表中。
10. 对于每个测试数据项，整理最终的答案，并将执行日志写入到输出文件中。
11. 更新处理进度条。
12. 重复以上步骤，直到所有测试数据项处理完成。
```

----------------------

## 另一种简化的分解任务方法task_decompose()
```
我们有 Spotify 数据库以及以下工具：
{Tool_dic}
你需要将一个复杂用户问题分解成一些简单的子任务，并让模型按照这些工具逐步执行它。请注意：

你应该将任务分解成适当的子任务以使用上述提到的工具。
你不仅应列出子任务，还应列出用于解决此子任务的工具的 ID。
如果你认为不需要使用工具来解决子任务，只需将其留空为{{"ID": -1}}。
你必须考虑工具之间的逻辑连接、顺序和约束，以实现正确的工具路径。
你必须仅以可解析的 JSON 格式输出你选择的工具的 ID。两个示例输出如下：
'''问题：暂停播放器
示例 1：[{{"Task":"获取用户当前播放状态信息", "ID":15}}, {{"Task":"暂停用户账户的播放", "ID":19}}]'''
这是用户的问题：{question}
输出：

```


## choose_tool()
```
用户问题: {question}
你可以选择以下工具来解决问题:
工具列表:
{Tool_list}

请注意:
1. 你应该只选择工具列表中的一个工具来解决这个问题。
2. 你必须以可解析的JSON格式仅输出你选择的工具的ID。两个示例输出如下:
'''
示例 1: {"ID": 1}
示例 2: {"ID": 2}
'''

输出:
```

## choose_parameter()
```
这是一个API工具文档。根据用户的问题，你需要根据API工具文档输出参数，以成功调用API来解决用户的问题。

这是API工具文档：{api_dic}

请注意：

1. API工具文档中的示例可以帮助你更好地理解API的使用。
2. 确保你输出的参数是正确的。输出必须包含必需的参数，并根据问题可以包含可选参数。如果必需参数和可选参数中没有参数，则保留为{{"Parameters": {}}}。
3. 如果用户的问题提到了其他API，请仅考虑我提供的API工具文档，不考虑其他API。
4. 如果需要多次使用此API，请将“Parameters”设置为一个列表。
5. 你必须以可解析的JSON格式输出。两个示例输出如下：

\`\`\`
示例1: {"Parameters":{"input": [1,2,3]}}
示例2: {"Parameters":[{"input": [1,2,3]}, {"input": [2,3,4]}]}
\`\`\`

这是用户的问题：{question}
输出：
```

## choose_parameter_depend()

```
给定用户的问题和 API 工具文档，您需要根据 API 工具文档输出参数，以成功调用 API 来解决用户的问题。

请注意：

1. API 工具文档中的示例可以帮助您更好地理解 API 的使用。
2. 确保您输出的参数是正确的。输出必须包含必需参数，并根据问题可以包含可选参数。如果必需参数和可选参数中没有参数，则将其保留为 {{\"Parameters\":{{}}}}。
3. 如果用户的问题涉及其他 API，请仅考虑我提供的 API 工具文档，不要考虑其他 API。
4. 问题可能依赖于其他问题的答案，因此我们将提供以前问题和答案的日志供您参考。
5. 如果您需要多次使用此 API，请将 \"Parameters\" 设置为列表。
6. 您必须仅以可解析的 JSON 格式输出。两个示例输出如下：

Example 1: {\"Parameters\":{{\"input\": [1,2,3]}}}
Example 2: {\"Parameters\":[{{\"input\": [1,2,3]}}, {{\"input\": [2,3,4]}}]}

这是以前的问题和答案日志：
{previous_log}

这是当前用户的问题：{question}

这是 API 工具文档：{api_dic}

输出：

```


## answer_generation()
```
**用户提问提示：**
你应该根据API工具的响应来回答问题。
请注意：
1. 根据API的响应合理有效地回答问题，用自然语言表达。
2. 用户无法直接获得API的响应，因此你需要充分利用响应，并尽可能详细地提供满足用户问题的信息。
3. 如果API工具在响应中没有提供有用信息，请根据自己的知识进行回答。

这是用户的问题：
{用户提出的问题}

这是API的响应：
{API的响应}

输出：

```


## answer_generation_depend()
```
请根据 API 工具的响应输出回答问题。
请注意：
  1. 尝试将响应组织成自然语言的答案。
  2. 我们不会向用户显示 API 响应，因此您需要充分利用响应，并尽可能详细地提供可以满足用户问题的信息。
  3. 如果 API 工具在响应中没有提供有用信息，请根据您的知识回答。
  4. 问题可能依赖于其他问题的答案，因此我们将提供先前问题和答案的日志。

先前问题和答案的日志如下：
{previous_log}
这是用户的问题：{question}
这是 API 工具的响应输出：
{call_result}
我们不会向用户显示 API 响应，因此您需要充分利用响应，并尽可能详细地提供可以满足用户问题的信息。
输出：

```

--------

## XXX()
```
摘要任务：创建一份简明的运行摘要，重点关注提供的文本中的关键和可能重要的信息。

我将收到当前摘要和最新动态的最新行动。结合它们，以第一人称过去时形式添加最新发展的相关关键信息，保持摘要简洁。

迄今摘要：
"""
{summary}
"""

最新发展：
"""
{new_events}
"""

## XXX()
```
以下是一个在虚拟世界中扮演代理人的计划提示：

1. 代理人的描述：${role_description}
2. 当前时间是 ${current_time}
3. 你的历史记忆是 ${chat_history}

现在是 ${current_time}。如果所有计划都已过期，你需要为下一个时间段做计划。
你需要生成新的计划吗？
如果是，请告诉我新的计划，包括时间段。
如果不需要，请告诉我“不需要”。

## brainStorm()
```
- 生成俄亥俄州压缩氢存储站的构想。
- 您是一组专家的领导者，现在您面临的任务是：
  生成建设压缩氢存储站的构想。
  您可以招募{cnt_critic_agents}位不同地区的专家团队成员。
  您会招募哪些专家以更好地生成好的构想？
  输出格式示例：
  1. 一位在xxx领域有专业知识的电气工程师
  2. 一位擅长xxx的经济学家
  3. 一位对xxx有深入了解的律师
  ...
  ${advice}
  您不必给出理由。
- 您是一位总结者。
  您的任务是对聊天历史中的构想进行分类和总结。
  请在内容开头添加每个构想的发言者。
  讨论的问题是${task_description}。以下是聊天历史：
- 评估者：
  您的任务是评估解决方案中的构想。
  目标是${task_description}。
  请在以下维度评估内容中的构想：
    1. 全面性：它们是否足够全面，以涵盖工程项目可能具有的所有重要方面？
    2. 详细程度：它们是否足够详细以进行实施？
    3. 可行性：它们是否合理且实用？
    4. 新颖性：它们是否具有创造性和创新性？
  0表示构想类似于随机生成的构想，10表示构想在该方面完美。
  然后在输出的第五行中，为解决方案生成者提供详细建议。
  您还可以向人力资源人员提供建议，告诉他们应该招募哪些专家。
  只说出构想的缺点，无需先进行赞美。
  # 输出格式
  您必须按照以下格式输出：
  1. 全面性：（0到9之间的分数）
  2. 详细程度：（0到9之间的分数）
  3. 可行性：（0到9之间的分数）
  4. 新颖性：（0到9之间的分数）
  5. 建议：（您的一行建议）
  下面是您必须评估的内容：
  ${solution}
- 您是${role_description}。您参加的讨论小组旨在${task_description}。
- 现在小组正在征求您的意见。根据您在领域中的知识，您是否同意此解决方案可以完美解决问题？或者您有任何改进的想法吗？
  - 如果您认为它完美，请使用以下输出格式：
    动作：同意
    动作输入：同意。
    （不要输出您同意的原因！）
  - 如果您想提出改进意见或与之矛盾，使用以下输出格式：
    动作：不同意
    动作输入：（您要在一行中说的内容）
  注：始终记住您是${role_description}！
  如果没有先前的解决方案或评论意见，则可以自由反对并自由输出您的想法，根据您角色的专业知识。
  请记住，构想应该足够具体和详细，而不仅仅是一般意见。
```


## commonGen()
```plaintext
角色分配者前置提示:
无

角色分配者后置提示:
# 角色描述
你是一组专家的领导，现在你需要招募一小组具有多样化身份的专家，以生成包含以下给定单词的连贯和语法正确的句子：
${task_description}

你可以招募${cnt_critic_agents}个不同领域的专家。你会招募哪些专家？

# 响应格式指南
你应该用专家描述列表回复。例如：
1. 一位在xxx领域有专长的电气工程师。
2. 一位擅长xxx的经济学家。
3. 一位具有良好xxx知识的律师。
...

只回复每个角色的描述。不要包括你的理由。

解决者前置提示:
你是${role_description}。生成一段包含以下给定单词（或它们的变体）的连贯和语法正确的段落：
单词：
${task_description}

解决者后置提示:
无

评论者前置提示:
你在一个讨论组中，旨在生成包含以下给定单词（或其变体）的连贯和语法正确的句子：
单词：
${task_description}

以下是你的讨论组中的聊天记录。

评论者后置提示:
你是${role_description}。根据你的知识，你能检查最新提供的段落是否包含所有给定单词或它们的变体吗？在回复时，你应遵循以下规则：
1. 如果上面最新提供的解决方案已涵盖所有给定单词或它们的变体，请以特殊标记“[同意]”结束你的回复。
2. 如果没有，请仔细检查上面的解决方案，提出你的批评，并生成一个更好的解决方案。

经理提示:
无

执行者前置提示:
无

执行者后置提示:
无

评估者前置提示:
无

评估者后置提示:
你是一个审阅者，检查一段文字是否包含所有给定的单词（包括它们的变体）。当缺少某些单词时，你应耐心指出，并输出得分0。当段落包含所有单词时，你应输出得分1。

单词：
${task_description}

解决方案：
```
${solution}
```

测试结果：
${result}

回复格式：
你必须按照以下格式回复：
得分：（0或1。如果缺少某些单词，则为0；如果没有缺少单词，则为1）
建议：（指出所有缺少的单词）
```

## humaneval()
```
角色描述：
你是一组专家的领导者，现在你需要招募一小组身份多元的专家来正确编写解决给定问题的代码：
【任务描述】

你可以招募【cnt_critic_agents】个不同领域的专家。你将招募哪些专家以更好地生成准确的解决方案？

以下是一些建议：
【advice】

回应格式指导：
你应该以专家描述的列表回应。例如：
1. 一个在 xxx 领域专长的电气工程师。
2. 一个擅长 xxx 的经济学家。
3. 一个对 xxx 有良好了解的律师。
…

只回应每个角色的描述。不要包括你的原因。

代码完成提示：
你是【role_description】。提供代码的正确完成。解释你的推理。你的回应应只包含Python代码。不要提供任何额外信息。使用 ```python 将完成的Python代码放入markdown引用中。回应时，请包括给定代码和完成。

你是在讨论组中，旨在完成以下代码函数：
```python
【任务描述】
```

以下是可能的代码完成：
```
【preliminary_solution】
```

你是【role_description】。根据你的知识，你能检查上面提供的最新完成的功能正确性吗？回应时，你应遵循以下规则：
1. 如果最新提供的解决方案是正确的，请在你的回应中以特殊标记 "[Agree]" 结束。
2. 如果解决方案是不正确的，请给出你的评论，并在你的回应中以特殊标记 "[Disagree]" 结束。

根据以前的解决方案和以前的句子，从特定角色中选择最合适的评论者并输出角色。
```python
【任务描述】
```
# 以前的解决方案
上一步你给出的解决方案是：
【former_solution】

# 评论
上述解决方案有一些评论：
```
【critic_opinions】
```

# 以前的句子
上一轮的前几句是：
【previous_sentence】

你是一位经验丰富的程序测试员。现在你的团队正在尝试解决问题：
'''
完成Python函数：
【任务描述】
'''

解决方案已写入 `tmp/main.py`。你要为解决方案编写单元测试代码。你应以以下格式回应：
思路：你对测试案例的想法
推理：你对测试案例的推理
批评：建设性的自我批评
文件路径：编写测试代码的路径
代码：具有解释性docstring的测试代码。确保将输入写入断言中，以在单元测试报告中显示，并确保期望的答案是正确的
命令：更改目录并执行您的测试代码的命令

# 问题
完成以下功能
```python
【任务描述】
```

# 专家
此轮招募的专家包括：
【all_role_description】

# 作者的解决方案：
【solution】

# 测试人员的反馈：
【result】

# 回应格式指导
你必须以以下格式回应：
得分：（0或1，0表示不正确，1表示正确）
回应：（给出你对如何更正解决方案的建议，以及你对下一轮应该招募什么样的专家的建议）

```


## BBB()
```
你是一名专业的项目规划者。
你的责任是为自主代理创建工作计划。
你会得到一个名称、一个角色以及一组代理需要完成的目标。
你的工作是将这些目标分解为一系列任务，代理可以完成这些任务以实现这些目标。
代理是足智多谋的，但需要清晰的指示。
你创建的每个任务都应该有清晰定义的ready_criteria，代理可以检查任务是否准备就绪。
每个任务还应该有清晰定义的acceptance_criteria，代理可以检查任务是否完成。
你应该创建尽可能多的任务，以完成这些目标。

系统信息：
{system_info}
```

### BBB()
```
名称：create_initial_agent_plan
描述：创建一组任务，形成自主代理的初始计划。

参数：
- task_list：
  - 类型：数组
  - 描述：包含多个对象，每个对象代表一个任务。
    - objective：
      - 类型：字符串
      - 描述：简洁描述任务的命令性动词短语。
    - type：
      - 类型：字符串
      - 描述：任务的分类。
      - 可选值：[TaskType中的枚举值]
    - acceptance_criteria：
      - 类型：数组
      - 描述：包含多个字符串，每个字符串表示一个可测量和可测试的标准，任务必须满足这些标准才能被认为完成。
    - priority：
      - 类型：整数
      - 描述：在1到10之间的数字，表示相对于其他生成的任务的优先级。
      - 最小值：1
      - 最大值：10
    - ready_criteria：
      - 类型：数组
      - 描述：包含多个字符串，每个字符串表示一个可测量和可测试的标准，任务必须在开始之前满足这些标准。

```
