# task-decompose-quickstart
## 下面是一个prompt-1
```
您需要将一个复杂的用户问题分解为一些简单的子任务，并让模型逐步执行。

这是用户的问题：{question}

请注意：

您应该仅将这个复杂的用户问题分解为一些可以通过使用单一工具轻松执行的简单子任务。
每个简单子任务应该用自然语言表达。
每个子任务应包含原始问题的必要信息，并且应该是完整的、明确的和自洽的。
您只能以可解析的 JSON 格式输出您选择的工具的 ID。输出示例如下：
'''
{{"Tasks": ["任务1", "任务2", ...]}}
'''
输出：

```
## 以下是3个具体例子
```
以下是三个可以作为`{question}`填充的复杂任务示例：

1. "我需要为即将到来的夏天准备一次家庭度假，包括选择目的地、预订机票和酒店，并为全家人准备必需的旅行用品。我还需要考虑到旅行保险和特别的饮食要求。"

2. "我想为我的新家装修设计一个现代风格的客厅，需要选择适合的家具、窗帘和装饰品，并考虑到室内照明和颜色搭配。同时，我还需要确保所有材料的环保标准和预算控制。"

3. "我正在计划一个专业会议，需要处理与地点选择、参与者邀请、日程安排和餐饮服务相关的各种事务。此外，我还需要设立一套技术支持系统来进行在线直播和记录会议内容。"
```


## 下面是一个prompt-2
```
鉴于一个复杂用户问题，我已将该问题分解成一些简单的子任务。我认为这些任务之间存在着逻辑连接和顺序。因此，你需要帮助我输出这些逻辑连接和顺序。
你必须仅以可解析的JSON格式输出，格式如下：
```json
[
  {
    "task": "task",
    "id": "task_id",
    "dep": ["dependency_task_id1", "dependency_task_id2", ...]
  }
]
```
‘dep’字段表示生成新资源的前一个任务的id，当前任务依赖于该资源。如果没有依赖项，则将‘dep’设置为-1。
这是用户的问题：{question}
这些是该问题的子任务：
{task_ls}
输出：
```
## 以下是3个具体例子
当然，下面是三个示例，可以用来填充 `{question}` 和 `{task_ls}`：

例子1：
```
{question}: 如何准备一道经典的意大利面食？
{task_ls}:
1. 收集食材
2. 准备面团
3. 制作意大利面条
4. 煮意大利面
5. 准备酱料
6. 搭配酱料和意大利面
7. 享用美食
```

例子2：
```
{question}: 怎样在Python中实现一个简单的计算器？
{task_ls}:
1. 定义基本的数学运算功能
2. 实现用户输入的功能
3. 编写主函数
4. 测试代码
```

例子3：
```
{question}: 如何组织一场成功的线上研讨会？
{task_ls}:
1. 确定研讨会的主题和目标
2. 确定研讨会的日期、时间和时长
3. 确定参与者和主持人
4. 设置线上会议平台
5. 发送邀请邮件
6. 准备研讨会的议程和资料
7. 进行技术测试和准备
8. 主持研讨会
9. 收集反馈和总结经验
```



